--------
- tags: #ObjectAceType #acls #PowerView 
-------
## Enumeración de ACL con PowerView

Podemos usar PowerView para enumerar las ACL, pero la tarea de examinar _todos_ los resultados llevará mucho tiempo y probablemente sea inexacta. Por ejemplo, si ejecutamos la función, `Find-InterestingDomainAcl`recibiremos una gran cantidad de información que necesitaremos analizar para encontrarle algún sentido:
#### Usando Find-InterestingDomainAcl

```powershell-session
PS C:\htb> Find-InterestingDomainAcl

ObjectDN                : DC=INLANEFREIGHT,DC=LOCAL
AceQualifier            : AccessAllowed
ActiveDirectoryRights   : ExtendedRight
ObjectAceType           : ab721a53-1e2f-11d0-9819-00aa0040529b
AceFlags                : ContainerInherit
AceType                 : AccessAllowedObject
InheritanceFlags        : ContainerInherit
SecurityIdentifier      : S-1-5-21-3842939050-3880317879-2865463114-5189
IdentityReferenceName   : Exchange Windows Permissions
IdentityReferenceDomain : INLANEFREIGHT.LOCAL
IdentityReferenceDN     : CN=Exchange Windows Permissions,OU=Microsoft Exchange Security 
                          Groups,DC=INLANEFREIGHT,DC=LOCAL
IdentityReferenceClass  : group

ObjectDN                : DC=INLANEFREIGHT,DC=LOCAL
AceQualifier            : AccessAllowed
ActiveDirectoryRights   : ExtendedRight
ObjectAceType           : 00299570-246d-11d0-a768-00aa006e0529
AceFlags                : ContainerInherit
AceType                 : AccessAllowedObject
InheritanceFlags        : ContainerInherit
SecurityIdentifier      : S-1-5-21-3842939050-3880317879-2865463114-5189
IdentityReferenceName   : Exchange Windows Permissions
IdentityReferenceDomain : INLANEFREIGHT.LOCAL
IdentityReferenceDN     : CN=Exchange Windows Permissions,OU=Microsoft Exchange Security 
                          Groups,DC=INLANEFREIGHT,DC=LOCAL
IdentityReferenceClass  : group

<SNIP>
```

Si intentamos examinar todos estos datos durante una evaluación con un límite de tiempo, probablemente nunca los revisaremos todos ni encontraremos nada interesante antes de que finalice la evaluación. Ahora, existe una manera de utilizar una herramienta como PowerView de manera más efectiva: realizando una enumeración específica comenzando con un usuario sobre el que tenemos control. Centrémonos en el usuario `wley`, que obtuvimos tras resolver la última pregunta del `LLMNR/NBT-NS Poisoning - from Linux`apartado. Profundicemos y veamos si este usuario tiene algún derecho de ACL interesante que podamos aprovechar. Primero necesitamos obtener el SID de nuestro usuario objetivo para realizar una búsqueda eficaz.
### Usando Find-InterestingDomainAcl

```powershell-session
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb> $sid = Convert-NameToSid wley
```

Luego podemos usar la `Get-DomainObjectACL`función para realizar nuestra búsqueda específica. En el siguiente ejemplo, estamos usando esta función para encontrar todos los objetos de dominio sobre los que nuestro usuario tiene derechos asignando el SID del usuario usando la `$sid`variable a la `SecurityIdentifier`propiedad, que es lo que nos dice _quién_ tiene el derecho otorgado sobre un objeto. Una cosa importante a tener en cuenta es que si buscamos sin la bandera `ResolveGUIDs`, veremos resultados como los siguientes, donde la derecha `ExtendedRight`no nos da una idea clara de qué entrada ACE `wley`tiene el usuario `damundsen`. Esto se debe a que la `ObjectAceType`propiedad devuelve un valor GUID que no es legible por humanos.

Tenga en cuenta que este comando tardará un poco en ejecutarse, especialmente en un entorno grande. Puede tomar entre 1 y 2 minutos obtener un resultado en nuestro laboratorio.
#### Usando Get-DomainObjectACL

```powershell-session
PS C:\htb> Get-DomainObjectACL -Identity * | ? {$_.SecurityIdentifier -eq $sid}

ObjectDN               : CN=Dana Amundsen,OU=DevOps,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
ObjectSID              : S-1-5-21-3842939050-3880317879-2865463114-1176
ActiveDirectoryRights  : ExtendedRight
ObjectAceFlags         : ObjectAceTypePresent
ObjectAceType          : 00299570-246d-11d0-a768-00aa006e0529
InheritedObjectAceType : 00000000-0000-0000-0000-000000000000
BinaryLength           : 56
AceQualifier           : AccessAllowed
IsCallback             : False
OpaqueLength           : 0
AccessMask             : 256
SecurityIdentifier     : S-1-5-21-3842939050-3880317879-2865463114-1181
AceType                : AccessAllowedObject
AceFlags               : ContainerInherit
IsInherited            : False
InheritanceFlags       : ContainerInherit
PropagationFlags       : None
AuditFlags             : None
```
Podríamos buscar en Google el valor GUID `00299570-246d-11d0-a768-00aa006e0529`y descubrir [esta](https://docs.microsoft.com/en-us/windows/win32/adschema/r-user-force-change-password) página que muestra que el usuario tiene derecho a forzar el cambio de contraseña del otro usuario. Alternativamente, podríamos hacer una búsqueda inversa usando PowerShell para asignar el nombre correcto al valor GUID.
#### Realizar una búsqueda inversa y asignar un valor GUID

```powershell-session
PS C:\htb> $guid= "00299570-246d-11d0-a768-00aa006e0529"
PS C:\htb> Get-ADObject -SearchBase "CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)" -Filter {ObjectClass -like 'ControlAccessRight'} -Properties * |Select Name,DisplayName,DistinguishedName,rightsGuid| ?{$_.rightsGuid -eq $guid} | fl

Name              : User-Force-Change-Password
DisplayName       : Reset Password
DistinguishedName : CN=User-Force-Change-Password,CN=Extended-Rights,CN=Configuration,DC=INLANEFREIGHT,DC=LOCAL
rightsGuid        : 00299570-246d-11d0-a768-00aa006e0529
```
#### Usando el indicador -ResolveGUIDs

```powershell-session
PS C:\htb> Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} 

AceQualifier           : AccessAllowed
ObjectDN               : CN=Dana Amundsen,OU=DevOps,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
ActiveDirectoryRights  : ExtendedRight
ObjectAceType          : User-Force-Change-Password
ObjectSID              : S-1-5-21-3842939050-3880317879-2865463114-1176
InheritanceFlags       : ContainerInherit
BinaryLength           : 56
AceType                : AccessAllowedObject
ObjectAceFlags         : ObjectAceTypePresent
IsCallback             : False
PropagationFlags       : None
SecurityIdentifier     : S-1-5-21-3842939050-3880317879-2865463114-1181
AccessMask             : 256
AuditFlags             : None
IsInherited            : False
AceFlags               : ContainerInherit
InheritedObjectAceType : All
OpaqueLength           : 0
```

Es esencial que entendamos qué hacen nuestras herramientas y que tengamos métodos alternativos en nuestro conjunto de herramientas en caso de que una herramienta falle o se bloquee. Antes de continuar, echemos un vistazo rápido a cómo podemos hacer esto usando los cmdlets [Get-Acl](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-acl?view=powershell-7.2) y [Get-ADUser](https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-aduser?view=windowsserver2022-ps) que podemos encontrar disponibles en un sistema cliente. Saber realizar este tipo de búsqueda sin utilizar una herramienta como PowerView es muy beneficioso y podría diferenciarnos de nuestros pares. Es posible que podamos utilizar este conocimiento para lograr resultados cuando un cliente nos pide que trabajemos desde uno de sus sistemas y estamos restringidos a las herramientas que están disponibles en el sistema sin la capacidad de utilizar ninguna de las nuestras.

Este ejemplo no es muy eficiente y el comando puede tardar mucho en ejecutarse, especialmente en un entorno grande. Tomará mucho más tiempo que el comando equivalente usando PowerView. En este comando, primero hicimos una lista de todos los usuarios del dominio con el siguiente comando:
#### Crear una lista de usuarios de dominio

```powershell-session
PS C:\htb> Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName > ad_users.txt
```
#### Un bucle foreach útil

```powershell-session
PS C:\htb> foreach($line in [System.IO.File]::ReadLines("C:\Users\htb-student\Desktop\ad_users.txt")) {get-acl  "AD:\$(Get-ADUser $line)" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match 'INLANEFREIGHT\\wley'}}

Path                  : Microsoft.ActiveDirectory.Management.dll\ActiveDirectory:://RootDSE/CN=Dana 
                        Amundsen,OU=DevOps,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
ActiveDirectoryRights : ExtendedRight
InheritanceType       : All
ObjectType            : 00299570-246d-11d0-a768-00aa006e0529
InheritedObjectType   : 00000000-0000-0000-0000-000000000000
ObjectFlags           : ObjectAceTypePresent
AccessControlType     : Allow
IdentityReference     : INLANEFREIGHT\wley
IsInherited           : False
InheritanceFlags      : ContainerInherit
PropagationFlags      : None
```

Una vez que tengamos estos datos, podríamos seguir los mismos métodos que se muestran arriba para convertir el GUID a un formato legible por humanos para comprender qué derechos tenemos sobre el usuario objetivo.

Entonces, para resumir, comenzamos con el usuario `wley`y ahora tenemos control sobre el usuario `damundsen`a través del `User-Force-Change-Password`derecho extendido. Usemos Powerview para buscar dónde, si es que a algún lugar, `damundsen`podría llevarnos el control de la cuenta.
#### Enumeración adicional de derechos utilizando damundsen

```powershell-session
PS C:\htb> $sid2 = Convert-NameToSid damundsen
PS C:\htb> Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid2} -Verbose

AceType               : AccessAllowed
ObjectDN              : CN=Help Desk Level 1,OU=Security Groups,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
ActiveDirectoryRights : ListChildren, ReadProperty, GenericWrite
OpaqueLength          : 0
ObjectSID             : S-1-5-21-3842939050-3880317879-2865463114-4022
InheritanceFlags      : ContainerInherit
BinaryLength          : 36
IsInherited           : False
IsCallback            : False
PropagationFlags      : None
SecurityIdentifier    : S-1-5-21-3842939050-3880317879-2865463114-1176
AccessMask            : 131132
AuditFlags            : None
AceFlags              : ContainerInherit
AceQualifier          : AccessAllowed
```

Ahora podemos ver que nuestro usuario `damundsen`tiene `GenericWrite`privilegios sobre el `Help Desk Level 1`grupo. Esto significa, entre otras cosas, que podemos agregar cualquier usuario (o nosotros mismos) a este grupo y heredar cualquier derecho que este grupo le haya aplicado. Una búsqueda de los derechos conferidos a este grupo no arroja nada interesante.

Miremos y veamos si este grupo está anidado en otros grupos, recordando que la membresía en un grupo anidado significará que cualquier usuario en el grupo A heredará todos los derechos de cualquier grupo en el que esté anidado el grupo A (un miembro del mismo). Una búsqueda rápida nos muestra que el `Help Desk Level 1`grupo está anidado en el `Information Technology`grupo, lo que significa que podemos obtener cualquier derecho que el `Information Technology`grupo otorgue a sus miembros si simplemente nos agregamos al `Help Desk Level 1`grupo donde nuestro usuario `damundsen`tiene `GenericWrite`privilegios.
#### Investigación del grupo de nivel 1 de la mesa de ayuda con Get-DomainGroup

```powershell-session
PS C:\htb> Get-DomainGroup -Identity "Help Desk Level 1" | select memberof

memberof                                                                      
--------                                                                      
CN=Information Technology,OU=Security Groups,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
```

¡Esto es mucho para digerir! Recapitulemos dónde estamos:

- Tenemos control sobre el usuario `wley`cuyo hash recuperamos anteriormente en el módulo (evaluación) usando Responder y descifrado sin conexión usando Hashcat para revelar el valor de la contraseña en texto sin cifrar.
- Enumeramos los objetos `wley`sobre los que el usuario tiene control y descubrimos que podíamos forzar el cambio de contraseña del usuario.`damundsen`
- Desde aquí, descubrimos que el `damundsen`usuario puede agregar un miembro al `Help Desk Level 1`grupo usando `GenericWrite`privilegios.
- El `Help Desk Level 1`grupo está anidado en el `Information Technology`grupo, lo que otorga a los miembros de ese grupo cualquier derecho proporcionado al `Information Technology`grupo.

Ahora miremos a nuestro alrededor y veamos si los miembros de `Information Technology`pueden hacer algo interesante. Una vez más, al hacer nuestra búsqueda usando `Get-DomainObjectACL`nos muestra que los miembros del `Information Technology`grupo tienen `GenericAll`derechos sobre el usuario `adunn`, lo que significa que podríamos:

- Modificar la membresía del grupo
- Forzar cambio de contraseña
- Realice un ataque Kerberoasting dirigido e intente descifrar la contraseña del usuario si es débil
#### Investigando el grupo de tecnología de la información

```powershell-session
PS C:\htb> $itgroupsid = Convert-NameToSid "Information Technology"
PS C:\htb> Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $itgroupsid} -Verbose

AceType               : AccessAllowed
ObjectDN              : CN=Angela Dunn,OU=Server Admin,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
ActiveDirectoryRights : GenericAll
OpaqueLength          : 0
ObjectSID             : S-1-5-21-3842939050-3880317879-2865463114-1164
InheritanceFlags      : ContainerInherit
BinaryLength          : 36
IsInherited           : False
IsCallback            : False
PropagationFlags      : None
SecurityIdentifier    : S-1-5-21-3842939050-3880317879-2865463114-4016
AccessMask            : 983551
AuditFlags            : None
AceFlags              : ContainerInherit
AceQualifier          : AccessAllowed
```

Finalmente, veamos si el `adunn`usuario tiene algún tipo de acceso interesante que podamos aprovechar para acercarnos a nuestro objetivo.

El resultado anterior muestra que nuestro `adunn`usuario tiene `DS-Replication-Get-Changes`derechos `DS-Replication-Get-Changes-In-Filtered-Set`sobre el objeto de dominio. Esto significa que se puede aprovechar a este usuario para realizar un ataque DCSync. Cubriremos este ataque en profundidad en la `DCSync`sección.

## Enumeración de ACL con BloodHound

Ahora que hemos enumerado la ruta de ataque usando métodos más manuales como PowerView y cmdlets integrados de PowerShell, veamos cuánto más fácil habría sido identificar esto usando la extremadamente poderosa herramienta BloodHound. Tomemos los datos que recopilamos anteriormente con el ingeridor SharpHound y carguémoslos en BloodHound. A continuación, podemos configurar el `wley`usuario como nuestro nodo inicial, seleccionar la `Node Info`pestaña y desplazarnos hacia abajo hasta `Outbound Control Rights`. Esta opción nos mostrará los objetos sobre los que tenemos control directamente, a través de la membresía de grupo, y la cantidad de objetos que nuestro usuario podría llevarnos a controlar a través de rutas de ataque ACL en `Transitive Object Control`. Si hacemos clic en al `1`lado `First Degree Object Control`, vemos el primer conjunto de derechos que enumeramos, `ForceChangePassword`sobre el `damundsen`usuario.
#### Ver información del nodo a través de BloodHound

![imagen](https://academy.hackthebox.com/storage/modules/143/wley_damundsen.png)

Si hacemos clic derecho en la línea entre los dos objetos, aparecerá un menú. Si seleccionamos `Help`, se nos presentará ayuda sobre cómo abusar de este ACE, que incluye:

- Más información sobre los derechos, herramientas y comandos específicos que se pueden utilizar para llevar a cabo este ataque.
- Consideraciones de seguridad operativa (Opsec)
- Referencias externas.

Profundizaremos en este menú más adelante.
#### Investigando más a fondo ForceChangePassword

![imagen](https://academy.hackthebox.com/storage/modules/143/help_edge.png)

Si hacemos clic en al `16`lado `Transitive Object Control`, veremos la ruta completa que enumeramos minuciosamente anteriormente. Desde aquí, podríamos aprovechar los menús de ayuda de cada ventaja para encontrar formas de realizar mejor cada ataque.

#### Visualización de rutas de ataque potenciales a través de BloodHound

![imagen](https://academy.hackthebox.com/storage/modules/143/wley_path.png)

Finalmente, podemos usar las consultas prediseñadas en BloodHound para confirmar que el `adunn`usuario tiene derechos de DCSync.

#### Visualización de consultas previas a la compilación a través de BloodHound

![imagen](https://academy.hackthebox.com/storage/modules/143/adunn_dcsync.png)

Ahora hemos enumerado estas rutas de ataque de varias maneras. El siguiente paso será realizar esta cadena de ataques de principio a fin. ¡Vamos a profundizar en!